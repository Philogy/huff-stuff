#include "./Utils.huff"

// Storage Layout
#define constant SLOT_TOTAL_SUPPLY = FREE_STORAGE_POINTER()
#define constant SLOT_BALANCE_OF = FREE_STORAGE_POINTER()
#define constant SLOT_ALLOWANCE = FREE_STORAGE_POINTER()

// ERC20
// ERC20 -- constants
#define constant MAX_ALLOWANCE = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
// ERC20 -- errors
#define error ERC20InsufficientAllowanceError()
#define error ERC20InsufficientBalanceError()
#define error ZeroAddressError()
// ERC20 -- events
#define event Transfer(address indexed _from, address indexed _to, uint256 _value)
#define event Approval(address indexed _owner, address indexed _spender, uint256 _value)
// ERC20 -- non view
#define function transfer(address to, uint256 amount) nonpayable returns (bool)
#define function transferFrom(address from, address to, uint256 amount) nonpayable returns (bool)
#define function approve(address spender, uint256 amount) nonpayable returns (bool)
// ERC20 -- view
#define function name() view returns (string)
#define function symbol() view returns (string)
#define function decimals() view returns (uint8)
#define function totalSupply() view returns (uint256)
#define function balanceOf(address account) view returns (uint256)
#define function allowance(address owner, address spender) view returns (uint256)



#define macro INCREASE_SUPPLY() = takes(1) returns(0) {
  // takes:                     [supply_increase]
  [SLOT_TOTAL_SUPPLY] sload  // [total_supply, supply_increase]
  add                        // [new_total_supply]
  [SLOT_TOTAL_SUPPLY] sstore
}

#define macro DECREASE_SUPPLY() = takes(1) returns(0) {
  // takes:                     [supply_increase]
  [SLOT_TOTAL_SUPPLY] sload  // [total_supply, supply_increase]
  sub                        // [new_total_supply]
  [SLOT_TOTAL_SUPPLY] sstore
}

#define macro EMIT_TRANSFER() = takes(3) returns(0) {
  // takes:      [amount, from, to]
  0x00 mstore // [from, to]
  __EVENT_HASH(Transfer) 0x20 0x00 log3
}

#define macro DO_TRANSFER() = takes(3) returns(0) {
  // takes:                 [from, to, amount]
  dup2 ZERO_ADDR_CHECK() // [from, to, amount]
  dup2 dup2 dup5         // [amount, from, to, from, to, amount]
  EMIT_TRANSFER()        // [from, to, amount]
  dup3 swap1             // [from, amount, to, amount]
  DECREASE_BALANCE()     // [to, amount]
  INCREASE_BALANCE()     // []
  RETURN_SUCCESS()
}


#define macro APPROVE() = takes(0) returns(0) {
  NO_VALUE_CHECK()

  0x24 calldataload      // [allowance]
  0x04 calldataload dup1 // [spender, spender, allowance]
  dup1 ZERO_ADDR_CHECK() // [spender, spender, allowance]

  0x20 mstore            // [spender, allowance]
  caller 0x00 mstore     // [spender, allowance]
  dup2                   // [allowance, spender, allowance]
  CALC_ALLOWANCE_SLOT()  // [allowance_slot, allowance, spender, allowance]
  sstore                 // [spender, allowance]
  swap1 0x00 mstore      // [spender]
  caller                 // [msg.sender, spender]
  __EVENT_HASH(Approval) // [sig(Approval), msg.sender, spender]
  0x20 0x00 log3         // []

  RETURN_SUCCESS()
}

#define macro TRANSFER() = takes(0) returns(0) {
  NO_VALUE_CHECK()


  // -- zero address check
  0x04 calldataload   // [to]
  __FUNC_SIG(ZeroAddressError) dup2 REQUIRE() pop // ~= require(to != address(0))
  //                     [to]

  // -- decrease msg.sender balance
  // mstore(0x00, SLOT_BALANCE_OF)
  [SLOT_BALANCE_OF] callvalue mstore
  // mstore(0x20, msg.sender)
  caller 0x20 mstore
  0x24 calldataload   // [amount, to]
  0x40 callvalue sha3 // [from_bal_slot, amount, to]
  dup2 dup2 sload     // [from_bal, amount, from_bal_slot, amount, to]
  __FUNC_SIG(ERC20InsufficientBalanceError)
  SAFE_SUB()          // [from_new_bal, from_bal_slot, amount, to]
  swap1 sstore        // [amount, to]

  // -- increase to balance
  0x40 0x04 0x20 calldatacopy
  0x40 callvalue sha3 // [to_bal_slot, amount, to]
  swap1 dup2 sload    // [to_bal, amount, to_bal_slot, to]
  add swap1 sstore    // [to]

  // -- emit event
  caller              // [msg.sender, to]
  __EVENT_HASH(Transfer)
  //                     [Transfer.sig, msg.sender, to]
  0x20 0x40 log3      // []

  0x01 RETURN1_VALUE0()
}


/*
Memory layout:
0x00: scratch space / root slot
0x20: msg.sender / scratch space / root slot
0x40: from
0x60: to
0x80: amount
*/
#define macro TRANSFER_FROM() = takes(0) returns(0) {
  NO_VALUE_CHECK()

  // -- zero address check
  0x24 calldataload      // [to]
  __FUNC_SIG(ZeroAddressError) dup2 REQUIRE() pop
  //                        [to]

  // -- check and update allowance
  // calldatacopy cheaper than 3x (calldataload, mstore)
  0x60 0x04 0x40 calldatacopy
  // mstore(0x00, SLOT_ALLOWANCE)
  [SLOT_ALLOWANCE] callvalue mstore
  // mstore(0x20, msg.sender)
  caller 0x20 mstore
  //                        [to]
  0x04 calldataload      // [from, to]
  0x60 callvalue sha3    // [allowance_slot, from, to]
  0x44 calldataload dup1 // [amount, amount, allowance_slot, from, to]
  dup3 sload             // [allowance, amount, amount, allowance_slot, from, to]
  dup1 [MAX_ALLOWANCE] eq erc20_skip_allowance_update jumpi
  __FUNC_SIG(ERC20InsufficientAllowanceError) SAFE_SUB()
  //                        [new_allowance, amount, allowance_slot, from, to]
  dup1 swap3 sstore      // [amount, new_allowance, from, to]
  swap1 callvalue mstore // [amount, from, to]
  caller dup3            // [from, msg.sender, amount, from, to]
  __EVENT_HASH(Approval) // [Approval.sig, from, msg.sender, amount, from, to]
  0x20 callvalue log3    // [amount, from, to]
  dup1                   // [amount, amount, from, to]
  erc20_skipskip jump
  erc20_skip_allowance_update:
  //                        [allowance, amount, amount, allowance_slot, from, to]
    pop swap2 pop        // [amount, amount, from, to]
  erc20_skipskip:        // [amount, amount, from, to]

  // -- transfer
  // -- decrease from balance
  [SLOT_BALANCE_OF] 0x20 mstore
  0x40 0x20 sha3        // [from_bal_slot, amount, amount, from, to]
  swap1 dup2 sload      // [from_bal, amount, from_bal_slot, amount, from, to]
  __FUNC_SIG(ERC20InsufficientBalanceError)
  SAFE_SUB()            // [from_new_bal, from_bal_slot, amount, from, to]
  swap1 sstore          // [amount, from, to]

  // increase to balance
  [SLOT_BALANCE_OF] 0x40 mstore
  0x40 0x40 sha3        // [to_bal_slot, amount, from, to]
  swap1 dup2            // [to_bal_slot, amount, to_bal_slot, from, to]
  sload add             // [to_new_bal, to_bal_slot, from, to]
  swap1 sstore          // [from, to]

  // -- emit event
  __EVENT_HASH(Transfer)
  //                       [Transfer.sig, from, to]
  0x20 0x80 log3        // []

  0x01 RETURN1_VALUE0()
}

#define macro BALANCE_OF() = takes(0) returns(0) {
  NO_VALUE_CHECK()
  [SLOT_BALANCE_OF] callvalue mstore
  0x04 calldataload 0x20 mstore
  0x40 callvalue sha3 sload RETURN1_VALUE0()
}

#define macro TOTAL_SUPPLY() = takes(0) returns(0) {
  NO_VALUE_CHECK()
  [SLOT_TOTAL_SUPPLY] sload RETURN1()
}

#define macro _ERC20_SELECTOR_SWITCH() = takes(1) returns(1) {
  // takes: [selector]
  dup1 __FUNC_SIG(transfer) eq transfer jumpi
  dup1 __FUNC_SIG(transferFrom) eq transferFrom jumpi
  dup1 __FUNC_SIG(approve) eq approve jumpi
  dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi
  dup1 __FUNC_SIG(allowance) eq allowance jumpi
  dup1 __FUNC_SIG(totalSupply) eq totalSupply jumpi
  erc20_continue jump

  transfer:
    TRANSFER()
  transferFrom:
    TRANSFER_FROM()
  approve:
  balanceOf:
    BALANCE_OF()
  allowance:
  totalSupply:
    TOTAL_SUPPLY()

  0x0 0x0 revert

  erc20_continue: // [selector]
}
